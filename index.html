<!DOCTYPE html>
<html>
<head>
<title></title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!--[if lt IE 9]>
	<script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
<![endif]-->

<style type="text/css">
body{
	margin: 0px;
	font-size:20px;
	font-family:sans-serif;
	color:#333;

	padding-left: 20px;
	padding-bottom: 40px;
}

input, textarea{
	font-size: 30px;
	width: 50%;
	padding: 15px;
	border: 1px solid #ddd;
}

button{
	font-size: 30px;
	padding: 15px;
	border: 0px;
	background: #4ca;
	color: #fff;
	cursor: pointer;
}

form{
	padding-left: 40px;
}

#note_titles{
	vertical-align: top;
	width:30%;
	padding: 0px;
	box-sizing:border-box;
	background: #eee;
	display: inline-block;
	margin: 0px;
}

#note_titles li{
	list-style-type: none;
	padding: 10px;
}

#note_titles li:hover{
	background: lightblue;
}

.date_div{
	font-size: 14px;
	font-weight: 100;
	color: #888;
	padding-top: 4px;
}

.selected_note{
	background: gold;
}

#note_contents{
	vertical-align: top;
	width: 60%;
	box-sizing:border-box;
	display: inline-block;
	background: #ddd;
	padding: 20px;
	height: 300px;
}

</style>

</head>
<body>

<h1>Guide</h1>

<button id="delete_note" style="float:right; background:red;">Delete Note</button>
<button id="save" style="float:right; margin-right:140px;">Save all changes</button>
<button id="create_new">New note</button>
<br>
<ul id="note_titles">
	hi
</ul><!--
--><textarea id="note_contents">
</textarea>





<script src="/socket.io/socket.io.js"></script>
<script>
var yb = { id : function(str){return document.getElementById(str)} };
var socket = io();

var all_data = {}; // this will hold the data



/************************************************************************
GET DATA FROM STORAGE
************************************************************************/
socket.on('update_all_data',function(data){
	console.log(data);

	var output = '';
	all_data = data;

	var sorted_keys = [];

	for(var key in data){
		sorted_keys.push(key);
	}
	sorted_keys.sort( function(a,b){return data[a].updated < data[b].updated} );

	for(var i=0; i<sorted_keys.length; i++){
		var key = sorted_keys[i];

		// generate title from content
		var visible_title = data[key].content.match(/[^\s][^\n]*/i);

		// set up titles
		output += '<li id="'+key+'" onclick="switch_note('+key+')"><span class="titlespan">'+visible_title+'</span><div class="date_div">'+formatted_date(data[key].updated)+'</div></li>';
	}
	yb.id('note_titles').innerHTML = output;

	yb.id('note_titles').firstChild.click(); // select first note by default	
});




/************************************************************************
output the date as MM/DD/YYYY HH:MM (a|p)m
************************************************************************/
function formatted_date(date_number){
	var date = new Date(+date_number);
	var hours = date.getHours()%12;
	if(hours==0){hours='12';}
	var minutes = ('0'+date.getMinutes()).slice(-2);
	var am_or_pm = date.getHours()<12 ? 'AM' : 'PM';
	return (date.getMonth()+1) +'/'+ date.getDate() +'/'+ date.getFullYear() + ' '
		+ hours + ':' + minutes +' '+ am_or_pm;
}



/************************************************************************
SWITCH BETWEEN NOTES
************************************************************************/
function switch_note(key){
	try{document.querySelector('.selected_note').className = '';} catch(e){}

	// highlight the selected note
	yb.id(key).className = 'selected_note';

	// show the content of the note, but if there's nothing then just show an empty note
	yb.id('note_contents').value = all_data[key] ? all_data[key].content : '';

	// make sure the note's contents are associated with the correct key
	yb.id('note_contents').setAttribute('data-timestamp',key);
}



// this will store any new and/or updated notes before they get saved
var updated_notes = {};





/************************************************************************
CREATE NEW NOTE
************************************************************************/
yb.id('create_new').onclick = function(){
	// set key equal to creation date
	var key = +new Date()+'';
	updated_notes[key] = '';

	// create the dom element to hold the new note title and add it to the top of the list
	var newli = document.createElement('li');
	newli.innerHTML = '<span class="titlespan">New Note</span><div class="date_div">'+formatted_date(key)+'</div>';
	newli.setAttribute('id',key);
	newli.setAttribute('onclick','switch_note('+key+')');
	yb.id('note_titles').insertBefore(newli, yb.id('note_titles').firstChild);

	// make sure the note's contents are associated with the correct key
	//yb.id('note_contents').setAttribute('data-timestamp',key);

	// handle everything that happens when you switch to a new note (highlighting, etc)
	switch_note(key);

	yb.id('note_contents').focus(); // move the cursor to the text box

	// store updated content
	updated_notes[key] = {"updated":key, "content":""};
	all_data[key] = updated_notes[key];
}





/************************************************************************
EDIT NOTE
************************************************************************/
yb.id('note_contents').onkeyup = function(e){
	if(!(e.keyCode+'').match(/^(16|17|18|20|224|37|38|39|40)$/)){
		
		// make the save button say the right thing if it needs to change
		var savetext = yb.id('save').innerHTML;
		if(savetext!=='Save all changes'){
			yb.id('save').innerHTML = 'Save all changes';
		}

		// generate the updated title
		var newtitle = this.value.match(/[^\s][^\n]*/i);

		// store time and date of latest update
		var last_update = +new Date()+'';

		// automatic title editor
		var current_key = this.getAttribute('data-timestamp');
		yb.id(current_key).querySelector('.titlespan').innerHTML = newtitle ? newtitle[0] : 'untitled';

		// automatic date editor
		yb.id(current_key).querySelector('.date_div').innerHTML = formatted_date(last_update);

		// move current note to top of list if it's not there already
		var list = yb.id('note_titles');
		if(yb.id(current_key)!==list.firstChild){
			list.insertBefore(yb.id(current_key), list.firstChild);
		}

		// store updated content
		updated_notes[current_key] = {"updated":last_update, "content":this.value};
		all_data[current_key] = updated_notes[current_key];
	}
}



/************************************************************************
SAVE ALL CHANGES
************************************************************************/
yb.id('save').onclick = function(){
	socket.emit('save',updated_notes);
	yb.id('save').innerHTML = '...';
	updated_notes = {};
};
socket.on('saved', function(){
	yb.id('save').innerHTML = 'Saved';
});



/************************************************************************
DELETE SELECTED NOTE
************************************************************************/
yb.id('delete_note').onclick = function(){
	var current_key = yb.id('note_contents').getAttribute('data-timestamp');
	socket.emit('delete_note', current_key);

	yb.id('note_titles').removeChild(yb.id(current_key)); // remove deleted item from the dom
	yb.id('note_titles').firstChild.click(); // select the first title available
};





/*

Logic


New note
	click button
	create new note title
	associate it with the main text area
	highlight note title
	focus on the text area
	onkeyup, make title equal to the first non-space character followed by any number of non-newline characters

Select note

Save button
	delete old version of the note (based on data-timestamp attribute)
	save a new version of the note as {timestamp:note}
	or maybe save onchange or mouse out of window or on window blur or all of the above (onchange doesn't work too well)

ALTERNATE IDEA: AUTOSAVE
	use timestamp as date created and keep that consistent as the key
	change last updated property


things to add:
	- fix bug in json parse that appears because data somehow gets saved by being appended onto the end instead of put properly into the object
		- seems to happen with new notes
		- stuff seems to happen when more than one note has changed
		- it might have to do with the way the data is parsed and stringified
	- add are you sure for deletion
	- search functionality

*/

</script>
</body>
</html>